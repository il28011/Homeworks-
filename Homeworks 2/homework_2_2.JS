undefined + 1;
// NaN    Всі операції з NaN дають NaN
'true' == true
// false   через те що true змінюється на 1, а 'true' явно не може дорівнювати 1
false == 'false'
// false   по тій же причині 0 не є 'false'
null == ''
// false   через те що пустий рядок перетворюється на нуль, а null завжди перетворюється на undefind
3 ** (9 / 3);
// операція в дужках пріоритетніша, одже 9 / 3 = 3
// 3 ** 3 = 27
!!'false' == !!'true'
// оператор !! перетворює рядок 'false' на 'true' перетворення значення в булеве значення
// оператор !! перетворює рядок 'true' на 'true' перетворення значення в булеве значення
// І вийде true
0 || '0' && 1
// Пріоритет в оператора &&, тому при використанні отримуємо 1 ( при знаходженні значення false та це є першим що він шукає, він видасть нам перше значення true)
// Результат буде 1, так як при перетворення 0 стане False, а 1 стане True, то ми отримаємо саме істине значення
1 < 2 < 3
// 1 < 2 дасть нам true
// 1 < 3    (True перетворюється на 1) послідовність
// Результат true,  ми викорстали послідоність пріоритетів
'foo'+ + +'bar'
// Унітарний плюс перед рядком з текстом дасть нам NaN
// Унітарний плюс перед NaN дасть нам NaN
// 'foo' + NaN отримаємо рядок 'fooNaN'
3 ** 2 / 3;
//Пріоритетність у ** тому вийде 9/3
// 9 / 3 = 3
1 < 2 > 3
// 1 < 2   true,  true  перетворюється на 1
// 1 > 3   false
(+null == false) < 1;
// Пріоритет те що в душках, унітарний плюс змінює значення null на числове значення 0
// 0 == false  дасть нам true так як 0 перетвориться на false, а false в свою чергу дорівнює false
// 1 < 1   true ми перетворюємо на 1, а 1 в свою чергу не може бути менший за одиницю, тож ми отримаємо false
false && true || true
// Пріоритет &&, перша частина дасть нам false(за таблицею)
// false || true дасть нам true (за таблицею)
false && (true || true);
// Пріоритет в душках true || true дасть нам true
// false && true дасть нам false (також отримали це з таблиці)
(+null == false) < 1 ** 5;
// Пріоритет в душках, отже розглядаємо +null == false
// Унітарний + дасть нам числове значення 0, котре автоматично перетвориться в значення false
// false == false дасть нам true
// Далі в нас по пріоритету є степінь 1 ** 5 отримаємо 1
// Остаточний вираз маємо такий: True < 1 
// Результат: false   Так як true перетворюється на 1, а 1 не може бути менша за 1 